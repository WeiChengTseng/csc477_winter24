#!/usr/bin/env python3
import rospy
import tf
import tf.transformations as tr
from std_msgs.msg import String, Header, ColorRGBA
from nav_msgs.msg import OccupancyGrid, MapMetaData, Odometry
from geometry_msgs.msg import Twist, PoseStamped, Point
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker, MarkerArray
from math import sqrt, cos, sin, pi, atan2
from threading import Thread, Lock
from math import pi, log, exp
import random
import numpy as np
import sys
import pickle


class Particle(object):
    def __init__(self, id, x,y, theta):
        self.x = x
        self.y = y
        self.id = id
        self.theta = theta
    
class ParticleFilter(object):
    def __init__(self, num_particles, occ_grid_map, xmin, xmax, ymin, ymax,
                 laser_min_range, laser_max_range, laser_min_angle, laser_max_angle,
                 dynamics_translation_noise_std_dev,
                 dynamics_orientation_noise_std_dev,
                 beam_range_measurement_noise_std_dev):
        
        self.num_particles = num_particles
        self.ogm = occ_grid_map
        self.grid_map = np.array(self.ogm.data, dtype='int8')
        self.grid_map = self.grid_map.reshape((self.ogm.info.height, self.ogm.info.width))
        self.grid_bin = (self.grid_map == 0).astype('uint8')  # Cell is True iff probability of being occupied is zero  

        # Workspace boundaries 
        self.xmax = xmax
        self.xmin = xmin
        self.ymin = ymin
        self.ymax = ymax
        
        self.laser_max_angle = laser_max_angle
        self.laser_min_angle = laser_min_angle
        self.laser_max_range = laser_max_range
        self.laser_min_range = laser_min_range

        self.dynamics_translation_noise_std_dev = dynamics_translation_noise_std_dev
        self.dynamics_orientation_noise_std_dev = dynamics_orientation_noise_std_dev
        self.beam_range_measurement_noise_std_dev = beam_range_measurement_noise_std_dev
        
        self.cmd = None
        self.particles = []
        
        
    def init_particles(self):
        """Initializes particles uniformly randomly with map frame coordinates, 
        within the boundaries set by xmin,xmax, ymin,ymax"""
        
        for i in xrange(self.num_particles):
            found = False
            while not found:
                xrand = np.random.uniform(xmin*0.9, xmax*0.9)
                yrand = np.random.uniform(ymin*0.9, ymax*0.9)
                row, col = self.metric_to_grid_coords(xrand, yrand)
                if self.grid_bin[row, col]:
                    theta = np.random.uniform(0, 2*pi)
                    self.particles.append(Particle(i, xrand, yrand, theta))
                    found = True
                
    def handle_observation(self, z):
        pass
    
    def resample(self):
        pass

    def inject_random_particles(self):
        pass

    def measurement_likelihood(self, laser_scan_msg, particle):
        """
        If the robot was at the given particle, what would its laser scan
        be (in the known map)? This function evaluates the probability that
        the scan in laser_scan_msg was generated by the given particle. 
        
        Assume the measurement probability of a scan given the state of a particle
        can be written as the product of probabilities of individual beams
        given the state of the particle (i.e. independence given state). Also assume 
        that the bearing of each beam relative to the robot's orientation has zero noise, 
        so the only noise in the measurement comes from the range of each beam and is 
        distributed as N(0, beam_range_measurement_std_dev^2)
        """

        # Just like in the occupancy grid mapping assignment you might need this snippet
        # to convert the laser points from the husky_1/base_laser frame, whose z-axis points downwards
        # to the same frame pointing upwards
        
        #ranges_in_upwards_baselaser_frame = laser_scan_msg.ranges
        #angles_in_baselaser_frame = [(laser_scan_msg.angle_max - laser_scan_msg.angle_min)*float(i)/N + laser_scan_msg.angle_min for i in xrange(len(laser_scan_msg.ranges))]
        #angles_in_upwards_baselaser_frame = angles_in_baselaser_frame[::-1]
                
        return 0

    def predict_particle(self, particle, cmd_vel, dt):
        """
        Where will the particle go in after time dt passes?
        This function modifies the particle's state by simulating the effects
        of the given control forward in time. 

        Assume Dubins dynamics with variable forward velocity for the Husky.
        """
        pass
    

    def metric_to_grid_coords(self, x, y):
        """Converts metric coordinates to occupancy grid coordinates"""
        
        gx = (x - self.ogm.info.origin.position.x) / self.ogm.info.resolution
        gy = (y - self.ogm.info.origin.position.y) / self.ogm.info.resolution
        row = min(max(int(gy), 0), self.ogm.info.height)
        col = min(max(int(gx), 0), self.ogm.info.width)
        return (row, col)

class MonteCarloLocalization(object):
    
    def __init__(self, num_particles, xmin, xmax, ymin, ymax):
        rospy.init_node('monte_carlo_localization', anonymous=True)
        self.map_file = rospy.get_param("~map_file")

        dynamics_translation_noise_std_dev   = rospy.get_param("~dynamics_translation_noise_std_dev")
        dynamics_orientation_noise_std_dev   = rospy.get_param("~dynamics_orientation_noise_std_dev")
        beam_range_measurement_noise_std_dev = rospy.get_param("~beam_range_measurement_noise_std_dev")
        
        pkl_file = open(self.map_file, 'rb')
        self.ogm = pickle.load(pkl_file)
        pkl_file.close()
        
        self.q_baselink_baselaser = np.array([1.0, 0, 0, 0])
        self.R_baselink_baselaser = tr.quaternion_matrix(self.q_baselink_baselaser)[0:3,0:3]
        self.p_baselink_baselaser = np.array([0.337, 0.0, 0.308])

        self.pf = ParticleFilter(num_particles, self.ogm, xmin, xmax, ymin, ymax, 0, 0, 0, 0,
                                 dynamics_translation_noise_std_dev,
                                 dynamics_orientation_noise_std_dev,
                                 beam_range_measurement_noise_std_dev)
        
        self.pf.init_particles()

        self.mutex = Lock()
        
        self.particles_pub = rospy.Publisher('/husky_1/particle_filter/particles', MarkerArray, queue_size=1)
        self.laser_sub = rospy.Subscriber('/husky_1/scan', LaserScan, self.laser_scan_callback, queue_size=1)
        self.cmd_sub = rospy.Subscriber('/husky_1/cmd_vel', Twist, self.cmd_callback, queue_size=1)

    def cmd_callback(self, msg):
        self.mutex.acquire()
        self.pf.cmd = msg
        self.mutex.release()
        
    def laser_scan_callback(self, msg):        
        self.pf.min_laser_angle = msg.angle_min
        self.pf.max_laser_angle = msg.angle_max
        self.pf.min_laser_range = msg.range_min
        self.pf.max_laser_range = msg.range_max

        self.mutex.acquire()
        self.pf.handle_observation(msg)
        self.mutex.release()
            
    def get_particle_marker(self, timestamp, particle):
        msg = Marker()
        msg.header.stamp = timestamp
        msg.header.frame_id = 'map'
        msg.ns = 'particles'
        msg.id = particle.id
        msg.type = 0  # arrow
        msg.action = 0 # add/modify
        msg.lifetime = rospy.Duration(1)

        yaw_in_map = particle.theta
        vx = cos(yaw_in_map)
        vy = sin(yaw_in_map)

        msg.color = ColorRGBA(0, 1.0, 0, 1.0)
        
        msg.points.append(Point(particle.x, particle.y, 0.2))
        msg.points.append(Point(particle.x + 0.3*vx, particle.y + 0.3*vy, 0.5))
        
        msg.scale.x = 0.05
        msg.scale.y = 0.15
        msg.scale.z = 0.1
        return msg
        
    def run(self):
        rate = rospy.Rate(20)
        while not rospy.is_shutdown():

            ma = MarkerArray()
            ts = rospy.Time.now()
            for particle in self.pf.particles:
                ma.markers.append(self.get_particle_marker(ts, particle))

            self.particles_pub.publish(ma)
            rate.sleep()

    
if __name__ == '__main__':
    num_particles = 100

    # Workspace boundaries in meters
    xmin = -10
    xmax = 10
    ymin = -10
    ymax = 10
    
    mcl = MonteCarloLocalization(num_particles, xmin, xmax, ymin, ymax)
    mcl.run()


